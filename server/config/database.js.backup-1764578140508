const { Pool } = require('pg');
require('dotenv').config();

/**
 * Validation des variables d'environnement
 */
const validateEnvironment = () => {
  const required = [
    'DB_HOST', 'DB_NAME', 'DB_USER', 'DB_PASSWORD',
    'JWT_SECRET', 'NODE_ENV'
  ];

  const missing = required.filter(key => !process.env[key]);

  if (missing.length > 0) {
    console.error('‚ùå Variables d\'environnement manquantes:', missing.join(', '));

    if (process.env.NODE_ENV === 'production') {
      throw new Error(`Variables manquantes: ${missing.join(', ')}`);
    }

    console.warn('‚ö†Ô∏è  Mode d√©veloppement - certaines variables manquent');
  }

  // V√©rifications de s√©curit√©
  if (process.env.DB_PASSWORD === 'ByGagoos2025!' ||
    process.env.DB_PASSWORD === 'postgres' ||
    process.env.DB_PASSWORD === 'password') {
    console.error('üö® CRITIQUE: Mot de passe de base de donn√©es trop faible !');
    if (process.env.NODE_ENV === 'production') {
      throw new Error('Mot de passe DB trop faible');
    }
  }

  if (!process.env.JWT_SECRET || process.env.JWT_SECRET.length < 32) {
    console.error('üö® CRITIQUE: JWT_SECRET trop court (< 32 chars)');
    if (process.env.NODE_ENV === 'production') {
      throw new Error('JWT_SECRET insuffisant');
    }
  }
};

// Ex√©cuter la validation
validateEnvironment();

/**
 * Configuration du pool PostgreSQL
 */
const poolConfig = {
  host: process.env.DB_HOST,
  port: parseInt(process.env.DB_PORT) || 5432,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,

  // Optimisation du pool
  max: parseInt(process.env.DB_POOL_MAX) || 20,
  min: parseInt(process.env.DB_POOL_MIN) || 2,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 10000,

  // Configuration SSL s√©curis√©e
  ssl: process.env.NODE_ENV === 'production' ? {
    rejectUnauthorized: process.env.DB_SSL_REJECT_UNAUTHORIZED !== 'false',
    ca: process.env.DB_SSL_CA,
    key: process.env.DB_SSL_KEY,
    cert: process.env.DB_SSL_CERT
  } : false,

  // Param√®tres avanc√©s
  application_name: `bygagoos-api-${process.env.NODE_ENV}`,
  statement_timeout: 30000,
  query_timeout: 30000,

  // Logging
  log: (messages) => {
    if (messages.duration > 1000) {
      console.warn(`‚è±Ô∏è  Requ√™te lente (${messages.duration}ms):`, {
        query: messages.query?.text?.substring(0, 200) || 'Unknown',
        params: messages.query?.values || []
      });
    }
  }
};

// Cr√©ation du pool
const pool = new Pool(poolConfig);

/**
 * √âv√©nements du pool
 */
pool.on('connect', () => {
  console.log('‚úÖ Nouvelle connexion PostgreSQL √©tablie');
});

pool.on('error', (err) => {
  console.error('‚ùå Erreur PostgreSQL:', {
    message: err.message,
    code: err.code,
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
  });

  if (process.env.NODE_ENV === 'production') {
    // En production, loguer l'erreur pour monitoring
    console.error('üö® Erreur critique de base de donn√©es');
  }
});

pool.on('remove', () => {
  console.log('üîå Connexion ferm√©e');
});

/**
 * Fonctions utilitaires
 */
const testConnection = async () => {
  const start = Date.now();
  let client;

  try {
    client = await pool.connect();
    const result = await client.query(`
      SELECT 
        NOW() as timestamp,
        version() as version,
        current_database() as database,
        current_user as user,
        inet_server_addr() as server_ip,
        pg_database_size(current_database()) as size_bytes
    `);

    const duration = Date.now() - start;

    console.log('‚úÖ Connexion PostgreSQL r√©ussie', {
      duration: `${duration}ms`,
      database: result.rows[0].database,
      version: result.rows[0].version.split(',')[0].trim(),
      size: `${Math.round(result.rows[0].size_bytes / 1024 / 1024)} MB`
    });

    return {
      success: true,
      duration,
      ...result.rows[0]
    };
  } catch (error) {
    console.error('‚ùå √âchec connexion PostgreSQL:', {
      message: error.message,
      code: error.code,
      duration: Date.now() - start
    });

    return {
      success: false,
      error: error.message,
      code: error.code
    };
  } finally {
    if (client) client.release();
  }
};

const getPoolStats = () => {
  return {
    total: pool.totalCount,
    idle: pool.idleCount,
    waiting: pool.waitingCount,
    max: pool.options.max,
    min: pool.options.min
  };
};

const queryWithTimeout = async (text, params, timeout = 30000) => {
  const client = await pool.connect();

  try {
    await client.query(`SET statement_timeout = ${timeout}`);
    const result = await client.query(text, params);
    return result;
  } catch (error) {
    if (error.code === '57014') {
      throw new Error(`Query timeout after ${timeout}ms`);
    }
    throw error;
  } finally {
    client.release();
  }
};

const transaction = async (callback) => {
  const client = await pool.connect();

  try {
    await client.query('BEGIN');
    const result = await callback(client);
    await client.query('COMMIT');
    return result;
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
};

// Exporter
module.exports = {
  pool,
  testConnection,
  getPoolStats,
  queryWithTimeout,
  transaction
};